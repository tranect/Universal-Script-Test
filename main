local Players, RService = game:GetService("Players"), game:GetService("RunService");
local LocalP, Mouse = Players.LocalPlayer, Players.LocalPlayer:GetMouse();
local Rm, Index, NIndex, NCall, Caller = getrawmetatable(game), getrawmetatable(game).__index, getrawmetatable(game).__newindex, getrawmetatable(game).__namecall, checkcaller or is_protosmasher_caller
setreadonly(Rm, false)
Rm.__newindex = newcclosure(function(self, Meme, Value)
    if Caller() then return NIndex(self, Meme, Value) end 
    if tostring(self) == "HumanoidRootPart" or tostring(self) == "BasePart" then 
        if Meme == "CFrame" and self:IsDescendantOf(LocalP.Character) then 
            return true
        end
    end
    return NIndex(self, Meme, Value)
end)
setreadonly(Rm, true)
local LoadingTime = tick();
local Commands, Prefix = {}, ""
getgenv().Notify = function(title, text, icon, time)
    game:GetService("StarterGui"):SetCore("SendNotification",{
        Title = title;
        Text = text;
        Icon = "rbxassetid://2541869220";
        Duration = time;
    }) 
end                

if not syn or not protectgui then
    getgenv().protectgui = function()end
end

local repo = 'https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
--Library = loadstring(game:HttpGet('https://lindseyhost.com/UI/LinoriaLib.lua'))();
local name = game.Players.LocalPlayer.Name
local Window = Library:CreateWindow({Title = ""..name.."", Center = true, AutoShow = true})

local Fonts = {1,2,3};


local flyBool = false
local Material1 = {"Plastic", "Neon", "ForceField"}
local Material2 = {"Plastic", "Neon", "ForceField"}
local AimParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
local SnapParts = {"Head", "Torso", "Legs"}
local UIFont = 1

Library:SetWatermark("Devours Universal Script " .. os.date("%x") .. " | v1")
Library:Notify("Loading UI...")
Library:Notify("Newest Version | v1")
Library:Notify("Right Shift to Toggle The GUI")
Library:Notify(""..LoadingTime.."")

local AimTab = Window:AddTab("Aimbot")
local VisTab = Window:AddTab("Visuals")
local RageTab = Window:AddTab("Rage")
local SettingsTab = Window:AddTab("Settings")

local AimbotTabbox1 = AimTab:AddLeftTabbox("Aimbot")
local Aim1 = AimbotTabbox1:AddTab("Aimbot")
Aim1:AddToggle("aim_enabled", {Text = "Enable"}):AddKeyPicker("aim_key", {Text = "Aimbot", Default = "X", Mode = "Hold"})
Aim1:AddToggle("fov_Circle", {Text = "FOV Circle"}):AddColorPicker("fovColor", { Default = Color3.fromRGB(255, 255, 255) })
Aim1:AddSlider("aimbot_distance", {Text = "Aimbot Distance", Default = 500, Min = 50, Max = 500, Rounding = 0})
Aim1:AddSlider("circle_radius", {Text = "Circle Radius", Default = 250, Min = 50, Max = 600, Rounding = 0})
Aim1:AddDropdown("aim_part", {Text = "Aim Part", Default = 1, Values = AimParts})

local VisTabbox1 = VisTab:AddLeftTabbox("Enemy ESP")
local Esp1 = VisTabbox1:AddTab("Enemy ESP")
Esp1:AddToggle("name_tags", {Text = "Nametags"}):AddColorPicker("nameColor", { Default = Color3.fromRGB(255, 255, 255) })
Esp1:AddToggle("distance", {Text = "Distance"})
Esp1:AddToggle("boxes", { Text = "Boxes" }):AddColorPicker("bColor", { Default = Color3.fromRGB(255, 255, 255) })
Esp1:AddToggle("head_dot", {Text = "Head Dot"})
Esp1:AddToggle("health_bar", {Text = "Healthbar"})
Esp1:AddToggle("snaplines", {Text = "Snaplines"})

local Esp2 = VisTabbox1:AddTab("ESP Settings")
Esp2:AddSlider("FontSize", {Text = "Font Size", Default = 14, Min = 8, Max = 24, Rounding = 0})
Esp2:AddSlider("esp_distance", {Text = "ESP Distance", Default = 500, Min = 0, Max = 500, Rounding = 0})
Esp2:AddDropdown("SelectedFont", { Text = "ESP Font", Default = 1, Values = Fonts })
Esp2:AddDropdown("SnaplinePart", {Text = "Snapline Part", Default = 1, Values = SnapParts})

local VisTabbox2 = VisTab:AddLeftTabbox("Local Chams")
local Chams1 = VisTabbox2:AddTab("Local")
local Chams2 = VisTabbox2:AddTab("Enemy Chams")
Chams2:AddToggle("enemy_chams", {Text = "Enemy Chams"}):AddColorPicker("eColor", { Default = Color3.fromRGB(255, 255, 255) })
Chams2:AddToggle("enemy_chams_ontop", {Text = "Always on Top"})
Chams2:AddSlider("enemy_chams_transparency", { Text = "Chams Transparency", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Chams2:AddSlider("enemy_transparency", { Text = "Enemy Transparency", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})

local VisTabbox3 = VisTab:AddRightTabbox("Crosshair")
local Cross1 = VisTabbox3:AddTab("Crosshair")
Cross1:AddToggle("crosshair", {Text = "Enable"}):AddColorPicker("crossColor", { Default = Color3.fromRGB(255, 255, 255) })
Cross1:AddSlider("cross_length", { Text = "Crosshair Length", Default = 12, Min = 2, Max = 64, Rounding = 0, Suffix = "px"})
Cross1:AddSlider("cross_thickness", { Text = "Crosshair Thickness", Default = 1, Min = 1, Max = 10, Rounding = 0})
Cross1:AddSlider("cross_trans", { Text = "Crosshair Transparency", Default = 100, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})

local VisTabbox4 = VisTab:AddRightTabbox("Render")
local Rend1 = VisTabbox4:AddTab("Render")
Rend1:AddToggle("clr_correction", {Text = "Color Correction"}):AddColorPicker("clrCorrct", {Default = Color3.fromRGB(255,255,255) })
Rend1:AddSlider("brightness", { Text = "Brightness", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Rend1:AddSlider("contrast", { Text = "Contrast", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Rend1:AddSlider("saturation", { Text = "Saturation", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Rend1:AddToggle("bloom", {Text = "Bloom"})
Rend1:AddSlider("bloom_intensity", { Text = "Intensity", Default = 0, Min = 0, Max = 40, Rounding = 0})
Rend1:AddSlider("bloom_size", { Text = "Size", Default = 0, Min = 0, Max = 56, Rounding = 0})
Rend1:AddSlider("bloom_threshold", { Text = "Threshold", Default = 0, Min = 0, Max = 40, Rounding = 0})

local PlayerTabbox1 = RageTab:AddLeftTabbox("Player")
local Player1 = PlayerTabbox1:AddTab("Player")
Player1:AddToggle("plr_mod", {Text = "Player Modification"})
Player1:AddSlider("player_speed", { Text = "Player Speed", Default = 10, Min = 10, Max = 100, Rounding = 0})
Player1:AddSlider("player_height", { Text = "Player Jump Height", Default = 30, Min = 30, Max = 100, Rounding = 0})

local ExploitsTabbox1 = RageTab:AddRightTabbox("Exploits")
local Exploits1 = ExploitsTabbox1:AddTab("Exploits")
Exploits1:AddLabel("Fly"):AddKeyPicker("flyKey", {Text = "Fly", Default = "F"})
Exploits1:AddLabel("Nolip"):AddKeyPicker("phaseKey", {Text = "Phase Key", Default = "C", Mode = "Toggle"})


local function UpdateTheme()
    Library.BackgroundColor = Options.BackgroundColor.Value;
    Library.MainColor = Options.MainColor.Value;
    Library.AccentColor = Options.AccentColor.Value;
    Library.AccentColorDark = Library:GetDarkerColor(Library.AccentColor);
    Library.OutlineColor = Options.OutlineColor.Value;
    Library.FontColor = Options.FontColor.Value;

    Library:UpdateColorsUsingRegistry();
end;

local function SetDefault()
    Options.FontColor:SetValueRGB(Color3.fromRGB(255, 255, 255));
    Options.MainColor:SetValueRGB(Color3.fromRGB(28, 28, 28));
    Options.BackgroundColor:SetValueRGB(Color3.fromRGB(20, 20, 20));
    Options.AccentColor:SetValueRGB(Color3.fromRGB(97, 14, 166));
    Options.OutlineColor:SetValueRGB(Color3.fromRGB(50, 50, 50));
    Toggles.Rainbow:SetValue(false);

    UpdateTheme();
end;

local Theme = SettingsTab:AddLeftGroupbox('Theme');
Theme:AddLabel('Background Color'):AddColorPicker('BackgroundColor', { Default = Library.BackgroundColor });
Theme:AddLabel('Main Color'):AddColorPicker('MainColor', { Default = Library.MainColor });
Theme:AddLabel('Accent Color'):AddColorPicker('AccentColor', { Default = Color3.fromRGB(97, 14, 166) });
Theme:AddToggle('Rainbow', { Text = 'Rainbow Accent Color' });
Theme:AddLabel('Outline Color'):AddColorPicker('OutlineColor', { Default = Library.OutlineColor });
Theme:AddLabel('Font Color'):AddColorPicker('FontColor', { Default = Library.FontColor });
Theme:AddButton('Default Theme', SetDefault);
Theme:AddToggle('Keybinds', { Text = 'Show Keybinds Menu', Default = true }):OnChanged(function()
    Library.KeybindFrame.Visible = Toggles.Keybinds.Value;
end);
Theme:AddToggle('Watermark', { Text = 'Show Watermark', Default = true }):OnChanged(function()
    Library:SetWatermarkVisibility(Toggles.Watermark.Value);
end);
local function tp()
    local Player = game.Players.LocalPlayer
    local TP = game:GetService("TeleportService")
    TP:Teleport(6055959032, Player)
end;
task.spawn(function()
    while game:GetService('RunService').RenderStepped:Wait() do
        if Toggles.Rainbow.Value then
            local Registry = Window.Holder.Visible and Library.Registry or Library.HudRegistry;

            for Idx, Object in next, Registry do
                for Property, ColorIdx in next, Object.Properties do
                    if ColorIdx == 'AccentColor' or ColorIdx == 'AccentColorDark' then
                        local Instance = Object.Instance;
                        local yPos = Instance.AbsolutePosition.Y;

                        local Mapped = Library:MapValue(yPos, 0, 1080, 0, 0.5) * 1.5;
                        local Color = Color3.fromHSV((Library.CurrentRainbowHue - Mapped) % 1, 0.8, 1);

                        if ColorIdx == 'AccentColorDark' then
                            Color = Library:GetDarkerColor(Color);
                        end;

                        Instance[Property] = Color;
                    end;
                end;
            end;
        end;
    end;
    
end);

task.spawn(function()
    while true do
        wait(1)

        if Library.Unloaded then break end
    end
end)

Toggles.Rainbow:OnChanged(function()
    if not Toggles.Rainbow.Value then
        UpdateTheme();
    end;
end);

Options.BackgroundColor:OnChanged(UpdateTheme);
Options.MainColor:OnChanged(UpdateTheme);
Options.AccentColor:OnChanged(UpdateTheme);
Options.OutlineColor:OnChanged(UpdateTheme);
Options.FontColor:OnChanged(UpdateTheme);

Library:OnUnload(function()
    print('Unloaded!')
    Library.Unloaded = true
end)
local function tp()
    local Player = game.Players.LocalPlayer
    local TP = game:GetService("TeleportService")
	game:GetService('TeleportService'):Teleport(game.PlaceId)
end;

local Extra = SettingsTab:AddRightTabbox("Extras")
local Feats = Extra:AddTab("Extras")
Feats:AddButton("Rejoin", tp)
Feats:AddLabel("discord || Devour#6859")

Theme:AddButton("Unload", function ()
    Library:Unload()
end)

Library:Notify("Loaded UI");

-- Features below

local lplr = game.Players.LocalPlayer -- Local Player
local camera = game:GetService("Workspace").CurrentCamera -- Camera
local CurrentCamera = game.Workspace.CurrentCamera -- Current Camera
local worldToViewportPoint = game.Workspace.CurrentCamera.worldToViewportPoint -- View Port Point
local UIS = game:GetService("UserInputService")

local dwCamera = game.Workspace.CurrentCamera
local dwRunService = game:GetService("RunService")
local dwUIS = game:GetService("UserInputService")
local dwEntities = game:GetService("Players")
local dwLocalPlayer = dwEntities.LocalPlayer
local dwMouse = dwLocalPlayer:GetMouse()

local HeadOff = Vector3.new(0, 0.2, 0)
local LegOff = Vector3.new(0,4.7,0)
local HeadOff2 = Vector3.new(0, 5.6, 0)
local SnapLeg = Vector3.new(0, 3.2, 0)
local HealthOff = Vector3.new(-6,0,0)
local currentGun = "M4A1"
local CurrentMap = "Gas Station"
local InGame = false
local DeathLoop = false

-- Box ESP
local BoxESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do
        local BoxOutline = Drawing.new("Square")
        BoxOutline.Visible = false
        BoxOutline.Color = Color3.new(0,0,0)
        BoxOutline.Thickness = 2
        BoxOutline.Transparency = 1
        BoxOutline.Filled = false
    
        local Box = Drawing.new("Square")
        Box.Visible = false
        Box.Color = Options.bColor.Value
        Box.Thickness = 1
        Box.Transparency = 1
        Box.Filled = false
    
        local HealthBarOutline = Drawing.new("Square")
        HealthBarOutline.Thickness = 3
        HealthBarOutline.Filled = false
        HealthBarOutline.Color = Color3.new(0,0,0)
        HealthBarOutline.Transparency = 1
        HealthBarOutline.Visible = false
    
        local HealthBar = Drawing.new("Square")
        HealthBar.Thickness = 1
        HealthBar.Filled = false
        HealthBar.Transparency = 1
        HealthBar.Visible = false
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    Box.Color = Options.bColor.Value
    
                    if onScreen and Toggles.boxes.Value == true or onScreen and Toggles.health_bar.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        BoxOutline.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        BoxOutline.Position = Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                        --BoxOutline.Visible = false
    
                        Box.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                        --Box.Visible = false
    
                        HealthBarOutline.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                        HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6,0)
                        --HealthBarOutline.Visible = false
                    
                        HealthBar.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) / (workspace[v.Character.Name].Humanoid.MaxHealth / math.clamp(workspace[v.Character.Name].Humanoid.Health, 0, workspace[v.Character.Name].Humanoid.MaxHealth)))
                        HealthBar.Position = Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                        HealthBar.Color = Color3.fromRGB(255 - 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 0)
                        --HealthBar.Visible = false

                        if texts <= Options.esp_distance.Value then

                            if Toggles.boxes.Value == true then
                                BoxOutline.Visible = true
                                Box.Visible = true
                            else
                                BoxOutline.Visible = false
                                Box.Visible = false
                            end
    
                            if Toggles.health_bar.Value == true then
                                HealthBar.Visible = true
                                HealthBarOutline.Visible = true
                            else
                                HealthBar.Visible = false
                                HealthBarOutline.Visible = false
                            end

                        else
                            BoxOutline.Visible = false
                            Box.Visible = false
                            HealthBar.Visible = false
                            HealthBarOutline.Visible = false
                        end
    
                    else
                        BoxOutline.Visible = false
                        Box.Visible = false
                        HealthBar.Visible = false
                        HealthBarOutline.Visible = false
                    end
                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                    HealthBar.Visible = false
                    HealthBarOutline.Visible = false
                end
            end)
    end
    
    game.Players.PlayerAdded:Connect(function(v)
        local BoxOutline = Drawing.new("Square")
        BoxOutline.Visible = false
        BoxOutline.Color = Color3.new(0,0,0)
        BoxOutline.Thickness = 2
        BoxOutline.Transparency = 1
        BoxOutline.Filled = false
    
        local Box = Drawing.new("Square")
        Box.Visible = false
        Box.Color = Options.bColor.Value
        Box.Thickness = 1
        Box.Transparency = 1
        Box.Filled = false
    
        local HealthBarOutline = Drawing.new("Square")
        HealthBarOutline.Thickness = 3
        HealthBarOutline.Filled = false
        HealthBarOutline.Color = Color3.new(0,0,0)
        HealthBarOutline.Transparency = 1
        HealthBarOutline.Visible = false
    
        local HealthBar = Drawing.new("Square")
        HealthBar.Thickness = 1
        HealthBar.Filled = false
        HealthBar.Transparency = 1
        HealthBar.Visible = false
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    Box.Color = Options.bColor.Value
    
                    if onScreen and Toggles.boxes.Value == true or onScreen and Toggles.health_bar.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        BoxOutline.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        BoxOutline.Position = Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                        --BoxOutline.Visible = false
    
                        Box.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                        --Box.Visible = false
    
                        HealthBarOutline.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                        HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6,0)
                        --HealthBarOutline.Visible = false
                    
                        HealthBar.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) / (workspace[v.Character.Name].Humanoid.MaxHealth / math.clamp(workspace[v.Character.Name].Humanoid.Health, 0, workspace[v.Character.Name].Humanoid.MaxHealth)))
                        HealthBar.Position = Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                        HealthBar.Color = Color3.fromRGB(255 - 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 0)
                        --HealthBar.Visible = false
    
                        if texts <= Options.esp_distance.Value then

                            if Toggles.boxes.Value == true then
                                BoxOutline.Visible = true
                                Box.Visible = true
                            else
                                BoxOutline.Visible = false
                                Box.Visible = false
                            end
    
                            if Toggles.health_bar.Value == true then
                                HealthBar.Visible = true
                                HealthBarOutline.Visible = true
                            else
                                HealthBar.Visible = false
                                HealthBarOutline.Visible = false
                            end

                        else
                            BoxOutline.Visible = false
                            Box.Visible = false
                            HealthBar.Visible = false
                            HealthBarOutline.Visible = false
                        end
    
                    else
                        BoxOutline.Visible = false
                        Box.Visible = false
                        HealthBar.Visible = false
                        HealthBarOutline.Visible = false
                    end
                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                    HealthBar.Visible = false
                    HealthBarOutline.Visible = false
                end
            end)
    end)

end
coroutine.wrap(BoxESP)()

-- Head Dot ESP
local HeadDotESP = function ()
    
    for i,v in pairs(game.Players:GetChildren()) do

        local CircleOutline = Drawing.new("Circle")
        CircleOutline.Visible = false
        CircleOutline.Radius = 30
        CircleOutline.Color = Color3.fromRGB(0, 0 ,0)
        CircleOutline.Thickness = 3
        CircleOutline.Filled = false
        CircleOutline.Transparency = 1
    
        local HeadCircle = Drawing.new("Circle")
        HeadCircle.Visible = false
        HeadCircle.Radius = 30
        HeadCircle.Color = Options.bColor.Value
        HeadCircle.Thickness = 1
        HeadCircle.Filled = false
        HeadCircle.Transparency = 1
    
            game:GetService("RunService").RenderStepped:Connect(function()
    
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
    
                    HeadCircle.Color = Options.bColor.Value
    
                    if onScreen == true and Toggles.head_dot.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        HeadCircle.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        HeadCircle.Radius = 350 / RootPosition.Z
                        HeadCircle.Visible = true
    
                        CircleOutline.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        CircleOutline.Radius = 350 / RootPosition.Z
                        CircleOutline.Visible = true

if texts <= Options.esp_distance.Value then
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        else
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        end

                    else
                        HeadCircle.Visible = false
                        CircleOutline.Visible = false
                    end
    
                else
                    HeadCircle.Visible = false
                    CircleOutline.Visible = false
                end
    
            end)
            
    end
    
    game.Players.PlayerAdded:Connect(function(v)
        
        local CircleOutline = Drawing.new("Circle")
        CircleOutline.Visible = false
        CircleOutline.Radius = 30
        CircleOutline.Color = Color3.fromRGB(0, 0 ,0)
        CircleOutline.Thickness = 3
        CircleOutline.Filled = false
        CircleOutline.Transparency = 1
    
        local HeadCircle = Drawing.new("Circle")
        HeadCircle.Visible = false
        HeadCircle.Radius = 30
        HeadCircle.Color = Options.bColor.Value
        HeadCircle.Thickness = 1
        HeadCircle.Filled = false
        HeadCircle.Transparency = 1
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
    
                    HeadCircle.Color = Options.bColor.Value
    
                    if onScreen == true and Toggles.head_dot.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        HeadCircle.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        HeadCircle.Radius = 350 / RootPosition.Z
                        HeadCircle.Visible = true
    
                        CircleOutline.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        CircleOutline.Radius = 350 / RootPosition.Z
                        CircleOutline.Visible = true
    
if texts <= Options.esp_distance.Value then
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        else
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        end

                    else
                        HeadCircle.Visible = false
                        CircleOutline.Visible = false
                    end
    
                else
                    HeadCircle.Visible = false
                    CircleOutline.Visible = false
                end
    
            end)
    end)

end
coroutine.wrap(HeadDotESP)()

-- Nametag ESP
local NametagESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do

        local NameESP = Drawing.new("Text")
        NameESP.Visible = false
        NameESP.Center = true
        NameESP.Outline = true
        NameESP.Font = Options.SelectedFont.Value
        NameESP.Size = Options.FontSize.Value
        NameESP.Color = Options.nameColor.Value
        NameESP.Text = v.Name
    
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, RootPart.Position + HeadOff2)
    
                    NameESP.Color = Options.nameColor.Value
                    NameESP.Size = Options.FontSize.Value
                    NameESP.Font = Options.SelectedFont.Value

                    if onScreen == true and Toggles.name_tags.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        NameESP.Position = Vector2.new(HeadPosition.X, HeadPosition.Y)
if texts <= Options.esp_distance.Value then
                            NameESP.Visible = true
                        else
                            NameESP.Visible = true
                        end

                    else
                        NameESP.Visible = false
                    end
    
                else
                    NameESP.Visible = false
                end
    
            end)
            
    end
    
    
    game.Players.PlayerAdded:Connect(function (v)
    
        local NameESP = Drawing.new("Text")
        NameESP.Visible = false
        NameESP.Center = true
        NameESP.Outline = true
        NameESP.Font = Options.SelectedFont.Value
        NameESP.Size = Options.FontSize.Value
        NameESP.Color = Options.nameColor.Value
        NameESP.Text = v.Name
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, RootPart.Position + HeadOff2)
    
                    NameESP.Color = Options.nameColor.Value
                    NameESP.Size = Options.FontSize.Value
                    NameESP.Font = Options.SelectedFont.Value
    
                    if onScreen == true and Toggles.name_tags.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        NameESP.Position = Vector2.new(HeadPosition.X, HeadPosition.Y)
    
    
 if texts <= Options.esp_distance.Value then
                            NameESP.Visible = true
                        else
                            NameESP.Visible = true
                        end

                    else
                        NameESP.Visible = false
                    end
    
                else
                    NameESP.Visible = false
                end
    
            end)
            
    
    end)
end
coroutine.wrap(NametagESP)()

-- Distance ESP
local DistanceESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do

        local DistESP = Drawing.new("Text")
        DistESP.Visible = false
        DistESP.Center = true
        DistESP.Outline = true
        DistESP.Font = Options.SelectedFont.Value
        DistESP.Size = Options.FontSize.Value
        DistESP.Color = Options.nameColor.Value
        DistESP.Text = ""
    
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    DistESP.Font = Options.SelectedFont.Value
                    DistESP.Size = Options.FontSize.Value
                    DistESP.Color = Options.nameColor.Value

                    --  or texts < 300 

                    if onScreen == true and Toggles.distance.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        DistESP.Position = Vector2.new(LegPosition.X, LegPosition.Y)
                        
                        DistESP.Text = tostring("(" .. texts .. ")")

                        if texts <= Options.esp_distance.Value then
                            DistESP.Visible = true
                        else
                            DistESP.Visible = false
                        end

                    else
                        DistESP.Visible = false
                    end
    
                else
                    DistESP.Visible = false
                end
    
            end)
    end
    
    game.Players.PlayerAdded:Connect(function (v)
    
        local DistESP = Drawing.new("Text")
        DistESP.Visible = false
        DistESP.Center = true
        DistESP.Outline = true
        DistESP.Font = Options.SelectedFont.Value
        DistESP.Size = Options.FontSize.Value
        DistESP.Color = Options.nameColor.Value
        DistESP.Text = ""
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    DistESP.Font = Options.SelectedFont.Value
                    DistESP.Size = Options.FontSize.Value
                    DistESP.Color = Options.nameColor.Value
                    
                    if onScreen == true and Toggles.distance.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        DistESP.Position = Vector2.new(LegPosition.X, LegPosition.Y)
                        
                        DistESP.Text = tostring("(" .. texts .. ")")
    
if texts <= Options.esp_distance.Value then
                            DistESP.Visible = true
                        else
                            DistESP.Visible = true
                        end

                    else
                        DistESP.Visible = false
                    end
    
                else
                    DistESP.Visible = false
                end
    
            end)
    
    end)

end
coroutine.wrap(DistanceESP)()

-- Snaplines ESP
local SnaplineESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do

        local lineSnap = Drawing.new("Line")
        lineSnap.Visible =  false
        lineSnap.Thickness = 1
        lineSnap.Color = Options.bColor.Value
        
        game:GetService("RunService").RenderStepped:Connect(function ()
            if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)   
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - SnapLeg)
    
                lineSnap.Color = Options.bColor.Value
    
                if onScreen and Toggles.snaplines.Value == true then
    
                    local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                    if Options.SnaplinePart.Value == "Head" then
                        lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                        lineSnap.To = Vector2.new(HeadPosition.X, HeadPosition.Y)
                    else 
                        if Options.SnaplinePart.Value == "Torso" then
                            lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                            lineSnap.To = Vector2.new(RootPosition.X, RootPosition.Y)
                        else
                            if Options.SnaplinePart.Value == "Legs" then
                                lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                                lineSnap.To = Vector2.new(LegPosition.X, LegPosition.Y)
                            end
                        end
end
if texts <= Options.esp_distance.Value then
                        lineSnap.Visible = true
                    else
                        lineSnap.Visible = true
                    end

                else
                    lineSnap.Visible = false
                end
            else
                lineSnap.Visible = false
            end
        end)
    end
    game.Players.PlayerAdded:Connect(function (v)
    
        local lineSnap = Drawing.new("Line")
        lineSnap.Visible =  false
        lineSnap.Thickness = 1
        lineSnap.Color = Options.bColor.Value
        
        game:GetService("RunService").RenderStepped:Connect(function ()
            if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)   
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - SnapLeg)
    
                lineSnap.Color = Options.bColor.Value
    
                if onScreen and Toggles.snaplines.Value == true then
    
                    local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                    if Options.SnaplinePart.Value == "Head" then
                        lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                        lineSnap.To = Vector2.new(HeadPosition.X, HeadPosition.Y)
                    else 
                        if Options.SnaplinePart.Value == "Torso" then
                            lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                            lineSnap.To = Vector2.new(RootPosition.X, RootPosition.Y)
                        else
                            if Options.SnaplinePart.Value == "Legs" then
                                lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                                lineSnap.To = Vector2.new(LegPosition.X, LegPosition.Y)
                            end
                        end
                       end 
if texts <= Options.esp_distance.Value then
                        lineSnap.Visible = true
                    else
                        lineSnap.Visible = true
                    end

                else
                    lineSnap.Visible = false
                end
            else
                lineSnap.Visible = false
            end
        end)
    
    end)

end
coroutine.wrap(SnaplineESP)()

-- Enemy Chams
function chams()
    game:GetService("RunService").RenderStepped:Connect(function()
        if Toggles.enemy_chams.Value == true then
            for i,v in pairs(game.Players:GetChildren()) do
                for i,b in pairs(v.Character:GetChildren()) do
                    if b:IsA("BasePart") and v.Character.Humanoid.Health > 0 then
                        if not b:FindFirstChild("BoxHandleAdornment") then
                            b.Transparency = 0.5
                            local box = Instance.new("BoxHandleAdornment", b)
                            box.AlwaysOnTop = Toggles.enemy_chams_ontop.Value
                            box.Adornee = b
                            box.Size = b.Size
                            box.Color3 = Options.eColor.Value
                            box.ZIndex = 1                                         
                            box.Transparency = Options.enemy_chams_transparency.Value / 100

                            repeat wait()
                                box.Color3 = Options.eColor.Value
                                box.Transparency = Options.enemy_chams_transparency.Value / 100
                                box.AlwaysOnTop = Toggles.enemy_chams_ontop.Value
                            until Toggles.enemy_chams.Value == false
                        end
                    end
                end
            end
        end
    end)
end
coroutine.wrap(chams)()

function destroyChams()
    game:GetService("RunService").RenderStepped:Connect(function ()
           for i,v in pairs(game.Players:GetChildren()) do
              for i,b in pairs(v.Character:GetChildren()) do
                  if b:IsA("BasePart") and v.Character.Humanoid.Health == 0 then
                      if b:FindFirstChild("BoxHandleAdornment") then
                          b.BoxHandleAdornment:Destroy()
                      end
                  end
              end
           end
    end)
end
coroutine.wrap(destroyChams)()

-- Crosshair
local CrosshairDown = Drawing.new("Line") -- y
local CrosshairCross = Drawing.new("Line") -- x

function makeCrosshair()
    game:GetService("RunService").RenderStepped:Connect(function ()
        if Toggles.crosshair.Value == true then

            CrosshairDown.Color = Options.crossColor.Value
            CrosshairDown.Thickness = Options.cross_thickness.Value
            CrosshairDown.Transparency = Options.cross_trans.Value / 100

            CrosshairCross.Color = Options.crossColor.Value
            CrosshairCross.Thickness = Options.cross_thickness.Value
            CrosshairCross.Transparency = Options.cross_trans.Value / 100

            if Toggles.crosshair.Value == true then

                CrosshairDown.Visible = true
                CrosshairCross.Visible = true
            
                CrosshairCross.From = Vector2.new((CurrentCamera.ViewportSize.X/2)+(Options.cross_length.Value/2+1), CurrentCamera.ViewportSize.Y/2) 
                CrosshairCross.To = Vector2.new(CurrentCamera.ViewportSize.X/2-(Options.cross_length.Value/2), CurrentCamera.ViewportSize.Y/2) 
            
                CrosshairDown.From = Vector2.new(CurrentCamera.ViewportSize.X/2, CurrentCamera.ViewportSize.Y/2+(Options.cross_length.Value/2)) 
                CrosshairDown.To = Vector2.new(CurrentCamera.ViewportSize.X/2, CurrentCamera.ViewportSize.Y/2-(Options.cross_length.Value/2))

            else
                CrosshairDown.Visible = false
                CrosshairCross.Visible = false
            end

        else
            CrosshairDown.Visible = false
            CrosshairCross.Visible = false
        end

    end)
end
coroutine.wrap(makeCrosshair)()

local aiming = false
local selectKey = Options.aim_key.Value
local fovcircle = Drawing.new("Circle")
local peekPressed = false
local origPos = CFrame.new(0,0,0)
local changedPos = CFrame.new(0,0,0)
local deathLoopPos = CFrame.new(0,0,0)

fovcircle.Visible = Toggles.fov_Circle.Value
fovcircle.Radius = Options.circle_radius.Value
fovcircle.Color = Options.fovColor.Value
fovcircle.Thickness = 1
fovcircle.Filled = false
fovcircle.Transparency = 1

fovcircle.Position = Vector2.new(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y / 2)

UIS.InputBegan:Connect(function(i)
    if i.KeyCode == Enum.KeyCode[Options.aim_key.Value] then
        aiming = true
        print("Aiming")
        print(Options.aim_key.Value)
    end
end)

UIS.InputEnded:Connect(function(i)
    if i.KeyCode == Enum.KeyCode[Options.aim_key.Value] then
        aiming = false
        print("Not Aiming")
        print(Options.aim_key.Value)
    end
end)

dwRunService.RenderStepped:Connect(function()
    
    local dist = math.huge -- controls the fov snap stuff
    local closest_char = nil

    fovcircle.Radius = Options.circle_radius.Value
    fovcircle.Color = Options.fovColor.Value
    fovcircle.Visible = Toggles.fov_Circle.Value

    
    if aiming and Toggles.aim_enabled.Value == true then

        for i,v in next, dwEntities:GetChildren() do 

            if v ~= dwLocalPlayer and
            v.Character and
            v.Character:FindFirstChild("HumanoidRootPart") and
            v.Character:FindFirstChild("Humanoid") and
            v.Character:FindFirstChild("Humanoid").Health > 0 then

                if v.Team ~= dwLocalPlayer.Team then

                    local char = v.Character
                    local char_part_pos, is_onscreen = dwCamera:WorldToViewportPoint(char[Options.aim_part.Value].Position)

                    if is_onscreen then

                        local mag = (Vector2.new(dwMouse.X, dwMouse.Y) - Vector2.new(char_part_pos.X, char_part_pos.Y)).Magnitude

                        if mag < dist and mag < Options.circle_radius.Value then

                            dist = mag
                            closest_char = char

                        end
                    end
                end
            end
        end

        if closest_char ~= nil and
        closest_char:FindFirstChild("HumanoidRootPart") and
        closest_char:FindFirstChild("Humanoid") and
        closest_char:FindFirstChild("Humanoid").Health > 0 and TweenStatus == nil then

            dwCamera.CFrame = CFrame.new(dwCamera.CFrame.Position, closest_char[Options.aim_part.Value].Position)
            --mousemoverel(((closest_char[Options.aim_part.Value].Position.X - MouseLocation.X)  / 0.5), ((closest_char[Options.aim_part.Value].Position.Y - MouseLocation.Y) / 0.5))
        end

    end
end)


local playerMods = function ()
    
    game:GetService("RunService").RenderStepped:Connect(function()

        if Toggles.plr_mod.Value == true then

            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Options.player_speed.Value
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = Options.player_height.Value

        else

        end
    end)

end
coroutine.wrap(playerMods)()

local PhaseKey = function ()
end
coroutine.wrap(PhaseKey)()
-- After the features / exploits
local flyBool = false
Options.flyKey:OnClick(function()

    if flyBool == false then
        flyBool = true
        print(flyBool)
    else
        flyBool = false
        print(flyBool)
    end

    function flyEnable()

        while flyBool == true do

            repeat wait()

                repeat wait()
                until game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:findFirstChild("Torso") and game.Players.LocalPlayer.Character:findFirstChild("Humanoid")
                local mouse = game.Players.LocalPlayer:GetMouse()
                repeat wait() until mouse

                local plr = game.Players.LocalPlayer
                local Torso = game.Players.LocalPlayer.Character.Torso
                local flying = false
                local deb = true
                local ctrl = {f = 0, b = 0, l = 0, r = 0}
                local lastctrl = {f = 0, b = 0, l = 0, r = 0}
                local maxspeed = 200
                local speed = 0
                local WKey = Enum.KeyCode.W
                local AKey = Enum.KeyCode.A
                local SKey = Enum.KeyCode.S
                local DKey = Enum.KeyCode.D

                function Fly()
                local bg = Instance.new("BodyGyro", Torso)
                bg.P = 9e4
                bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
                bg.cframe = Torso.CFrame
                local bv = Instance.new("BodyVelocity", Torso)
                bv.velocity = Vector3.new(0,0.1,0)
                bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
                repeat wait()
                game.Players.LocalPlayer.Character.Humanoid.PlatformStand = true
                if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                speed = speed+3+(speed/maxspeed)
                if speed > maxspeed then
                speed = maxspeed
                end
                elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                speed = speed-5
                if speed < 0 then
                speed = 0
                end
                end
                if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
                elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                else
                bv.velocity = Vector3.new(0,0.1,0)
                end
                bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
                until not flying or value == false
                ctrl = {f = 0, b = 0, l = 0, r = 0}
                lastctrl = {f = 0, b = 0, l = 0, r = 0}
                speed = 0
bv:Destroy()
bg:Destroy()
                game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
                end
                
                UIS.InputBegan:Connect(function(i)
                    Library:Notify("Fly Active")
                    if i.KeyCode == Enum.KeyCode[Options.flyKey.Value] then
                        if flying then 
                            flying = false
                        else
                            flying = true
                            Fly()
                        end
                    elseif i.KeyCode == WKey then
                        ctrl.f = 1
                    elseif i.KeyCode == SKey then
                        ctrl.b = -1
                    elseif i.KeyCode == AKey then
                        ctrl.l = -1
                    elseif i.KeyCode == DKey then
                        ctrl.r = 1
                    end
                end)
                
                UIS.InputEnded:Connect(function(i)
                    Library:Notify("Fly Inactive")
bv:Destroy()
bg:Destroy()
                    if i.KeyCode == WKey then
                        ctrl.f = 0
                    elseif i.KeyCode == SKey then
                        ctrl.b = 0
                    elseif i.KeyCode == AKey then
                        ctrl.l = 0
                    elseif i.KeyCode == DKey then
                        ctrl.r = 0
                    end
                end)
                Fly()

                if flying == false then
                    game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
                end

            until flyBool== false
            
        end

        if flyBool == false then
            flying = false
        end
    end
    coroutine.wrap(flyEnable)()

end)



local RenderEdit = function ()

    local filter = Instance.new("ColorCorrectionEffect", game:GetService("Workspace").Camera)
    local bloom = Instance.new("BloomEffect", game:GetService("Workspace").Camera)

    game:GetService("RunService").RenderStepped:Connect(function ()
        
        if Toggles.clr_correction.Value == true then
            filter.Brightness = Options.brightness.Value / 100
            filter.Contrast = Options.contrast.Value / 100
            filter.Enabled = true
            filter.Saturation = Options.saturation.Value / 100
            filter.TintColor = Options.clrCorrct.Value
        if Toggles.bloom.Value == true then
            
            bloom.Enabled = true
            bloom.Intensity = Options.bloom_intensity.Value / 100
            bloom.Size = Options.bloom_size.Value
            bloom.Threshold = Options.bloom_threshold.Value
        else
            bloom.Enabled = false
        end
        end
    end)
end
coroutine.wrap(RenderEdit)()
local KeysTable = {
    ["W"] = false;["A"] = false;
    ["S"] = false;["D"] = false;
    ["LeftControl"] = false;["LeftShift"] = false;
}
local Uis = game:GetService("UserInputService")
local rm = getrawmetatable(game) or debug.getrawmetatable(game) or getmetatable(game)
local Flyspeed, Blinkspeed = 5, 2;

local Players, RService, RStorage, VUser, SGui, TPService = game:GetService("Players"), game:GetService("RunService"), game:GetService("ReplicatedStorage"), game:GetService("VirtualUser"), game:GetService("StarterGui"), game:GetService("TeleportService")
local Client, Mouse, Camera, CF, INew, Vec3, Vec2, UD2, UD = Players.LocalPlayer, Players.LocalPlayer:GetMouse(), workspace.CurrentCamera, CFrame.new, Instance.new, Vector3.new, Vector2.new, UDim2.new, UDim.new;
if setreadonly then setreadonly(rm, true) else make_writeable(rm, false) end
local Flying, NoClip, NoClipKey = false,false, "c"

RService.Stepped:Connect(function()
    if NoClip == true and LocalP and LocalP.Character and LocalP.Character:FindFirstChild("Humanoid") then  -- fuck errors
            for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                    
                end
            end
        end
    end)
Mouse.KeyDown:Connect(function(Key)
    if Key == NoClipKey then 
        NoClip = not NoClip
Library:Notify("Noclip active")
    end
end)
Library:Notify("Loading Done")

