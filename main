
local Players, RService = game:GetService("Players"), game:GetService("RunService");
local LocalP, Mouse = Players.LocalPlayer, Players.LocalPlayer:GetMouse();
local Rm, Index, NIndex, NCall, Caller = getrawmetatable(game), getrawmetatable(game).__index, getrawmetatable(game).__newindex, getrawmetatable(game).__namecall, checkcaller or is_protosmasher_caller
setreadonly(Rm, false)
Rm.__newindex = newcclosure(function(self, Meme, Value)
    if Caller() then return NIndex(self, Meme, Value) end 
    if tostring(self) == "HumanoidRootPart" or tostring(self) == "BasePart" then 
        if Meme == "CFrame" and self:IsDescendantOf(LocalP.Character) then 
            return true
        end
    end
    return NIndex(self, Meme, Value)
end)
setreadonly(Rm, true)
local LoadingTime = tick();
local Commands, Prefix = {}, ""
getgenv().Notify = function(title, text, icon, time)
    game:GetService("StarterGui"):SetCore("SendNotification",{
        Title = title;
        Text = text;
        Icon = "rbxassetid://2541869220";
        Duration = time;
    }) 
end   
local function plrlist()
local plrs = game:GetService("Players")
local OHRP = plrs:GetChildren()
for i = 1, #OHRP do
i = #OHRP[i].Name
end
end;             
if not syn or not protectgui then
    getgenv().protectgui = function()end
end

local repo = 'https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
--Library = loadstring(game:HttpGet('https://lindseyhost.com/UI/LinoriaLib.lua'))();
local name = game.Players.LocalPlayer.Name
local Window = Library:CreateWindow({Title = "dev-hook", Center = true, AutoShow = true})


local Fonts = {1,2,3};

local flyBool = false
local Material1 = {"Plastic", "Neon", "ForceField"}
local Material2 = {"Plastic", "Neon", "ForceField"}
local AimParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
local SnapParts = {"Head", "Torso", "Legs"}
local UIFont = 1

Library:SetWatermark("Devours Universal Script " .. os.date("%x") .. " | v1")
Library:Notify("Loading UI...")
Library:Notify("Newest Version | v1")
Library:Notify("Right Shift to Toggle The GUI")
Library:Notify(""..LoadingTime.."")

local AimTab = Window:AddTab("Combat")
local VisTab = Window:AddTab("Visuals")
local RageTab = Window:AddTab("Exploits")
local SettingsTab = Window:AddTab("Settings")

local AimbotTabbox1 = AimTab:AddLeftTabbox("Aimbot")
local Aim1 = AimbotTabbox1:AddTab("Aimbot")
Aim1:AddToggle("aim_enabled", {Text = "Enable"}):AddKeyPicker("aim_key", {Text = "Aimbot", Default = "X", Mode = "Hold"})
Aim1:AddToggle("fov_Circle", {Text = "FOV Circle"}):AddColorPicker("fovColor", { Default = Color3.fromRGB(255, 255, 255) })
Aim1:AddSlider("aimbot_distance", {Text = "Aimbot Distance", Default = 500, Min = 50, Max = 500, Rounding = 0})
Aim1:AddSlider("circle_radius", {Text = "Circle Radius", Default = 250, Min = 50, Max = 600, Rounding = 0})
Aim1:AddDropdown("aim_part", {Text = "Aim Part", Default = 1, Values = AimParts})

local VisTabbox1 = VisTab:AddLeftTabbox("Enemy ESP")
local Esp1 = VisTabbox1:AddTab("Enemy ESP")
Esp1:AddToggle("name_tags", {Text = "Nametags"}):AddColorPicker("nameColor", { Default = Color3.fromRGB(255, 255, 255) })
Esp1:AddToggle("distance", {Text = "Distance"})
Esp1:AddToggle("boxes", { Text = "Boxes" }):AddColorPicker("bColor", { Default = Color3.fromRGB(255, 255, 255) })
Esp1:AddToggle("head_dot", {Text = "Head Dot"})
Esp1:AddToggle("health_bar", {Text = "Healthbar"})
Esp1:AddToggle("snaplines", {Text = "Snaplines"})

local Esp2 = VisTabbox1:AddTab("ESP Settings")
Esp2:AddSlider("FontSize", {Text = "Font Size", Default = 14, Min = 8, Max = 24, Rounding = 0})
Esp2:AddSlider("esp_distance", {Text = "ESP Distance", Default = 500, Min = 0, Max = 500, Rounding = 0})
Esp2:AddDropdown("SelectedFont", { Text = "ESP Font", Default = 1, Values = Fonts })
Esp2:AddDropdown("SnaplinePart", {Text = "Snapline Part", Default = 1, Values = SnapParts})

local VisTabbox2 = VisTab:AddLeftTabbox("Local Chams")
local Chams1 = VisTabbox2:AddTab("Local")
Chams1:AddToggle("hand_chams", {Text = "Character Chams"}):AddColorPicker("handColor", { Default = Color3.fromRGB(255, 255, 255) })
Chams1:AddSlider("hand_chams_transparency", { Text = "Hand Chams Transparency", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Chams1:AddDropdown("hand_mat", {Text = "Hand Material", Default = 3, Values = Material2})

local Chams2 = VisTabbox2:AddTab("Enemy Chams")
Chams2:AddToggle("enemy_chams", {Text = "Enemy Chams"}):AddColorPicker("eColor", { Default = Color3.fromRGB(255, 255, 255) })
Chams2:AddToggle("enemy_chams_ontop", {Text = "Always on Top"})
Chams2:AddSlider("enemy_chams_transparency", { Text = "Chams Transparency", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Chams2:AddSlider("enemy_transparency", { Text = "Enemy Transparency", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})

local VisTabbox3 = VisTab:AddRightTabbox("Crosshair")
local Cross1 = VisTabbox3:AddTab("Crosshair")
Cross1:AddToggle("crosshair", {Text = "Enable"}):AddColorPicker("crossColor", { Default = Color3.fromRGB(255, 255, 255) })
Cross1:AddSlider("cross_length", { Text = "Crosshair Length", Default = 12, Min = 2, Max = 64, Rounding = 0, Suffix = "px"})
Cross1:AddSlider("cross_thickness", { Text = "Crosshair Thickness", Default = 1, Min = 1, Max = 10, Rounding = 0})
Cross1:AddSlider("cross_trans", { Text = "Crosshair Transparency", Default = 100, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})

local VisTabbox4 = VisTab:AddRightTabbox("Render")
local Rend1 = VisTabbox4:AddTab("Render")
Rend1:AddToggle("clr_correction", {Text = "Color Correction"}):AddColorPicker("clrCorrct", {Default = Color3.fromRGB(255,255,255) })
Rend1:AddSlider("brightness", { Text = "Brightness", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Rend1:AddSlider("contrast", { Text = "Contrast", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Rend1:AddSlider("saturation", { Text = "Saturation", Default = 0, Min = 0, Max = 100, Rounding = 0, Suffix = "%"})
Rend1:AddToggle("bloom", {Text = "Bloom"})
Rend1:AddSlider("bloom_intensity", { Text = "Intensity", Default = 0, Min = 0, Max = 40, Rounding = 0})
Rend1:AddSlider("bloom_size", { Text = "Size", Default = 0, Min = 0, Max = 56, Rounding = 0})
Rend1:AddSlider("bloom_threshold", { Text = "Threshold", Default = 0, Min = 0, Max = 40, Rounding = 0})

local PlayerTabbox1 = RageTab:AddLeftTabbox("Player")
local Player1 = PlayerTabbox1:AddTab("Player")
Player1:AddToggle("plr_mod", {Text = "Player Modification"})
Player1:AddSlider("player_speed", { Text = "Player Speed", Default = 10, Min = 10, Max = 100, Rounding = 0})
Player1:AddSlider("player_height", { Text = "Player Jump Height", Default = 30, Min = 30, Max = 100, Rounding = 0})

local ExploitsTabbox1 = RageTab:AddRightTabbox("Exploits")
local Exploits1 = ExploitsTabbox1:AddTab("Exploits")
Exploits1:AddLabel("Fly"):AddKeyPicker("flyKey", {Text = "Fly", Default = "F"})
Exploits1:AddLabel("Phase"):AddKeyPicker("phaseKey", {Text = "Phase Key", Default = "C", Mode = "Toggle"})
Exploits1:AddLabel("ClickTP"):AddKeyPicker("tpKey", {Text = "Click TP", Default = "E", Mode = "Hold"})

local FETabbox1 = RageTab:AddRightTabbox("Exploits")
local FE1 = FETabbox1:AddTab("Fe")
FE1:AddToggle("Fe_Godmode", {Text = "Godmode(Breaks Script)"})
FE1:AddToggle("Fe_All", {Text = "FeAll(Fekills The Server)"})

local function UpdateTheme()
    Library.BackgroundColor = Options.BackgroundColor.Value;
    Library.MainColor = Options.MainColor.Value;
    Library.AccentColor = Options.AccentColor.Value;
    Library.AccentColorDark = Library:GetDarkerColor(Library.AccentColor);
    Library.OutlineColor = Options.OutlineColor.Value;
    Library.FontColor = Options.FontColor.Value;

    Library:UpdateColorsUsingRegistry();
end;

local function SetDefault()
    Options.FontColor:SetValueRGB(Color3.fromRGB(255, 255, 255));
    Options.MainColor:SetValueRGB(Color3.fromRGB(28, 28, 28));
    Options.BackgroundColor:SetValueRGB(Color3.fromRGB(20, 20, 20));
    Options.AccentColor:SetValueRGB(Color3.fromRGB(97, 14, 166));
    Options.OutlineColor:SetValueRGB(Color3.fromRGB(50, 50, 50));
    Toggles.Rainbow:SetValue(false);

    UpdateTheme();
end;

local Theme = SettingsTab:AddLeftGroupbox('Theme');
Theme:AddLabel('Background Color'):AddColorPicker('BackgroundColor', { Default = Library.BackgroundColor });
Theme:AddLabel('Main Color'):AddColorPicker('MainColor', { Default = Library.MainColor });
Theme:AddLabel('Accent Color'):AddColorPicker('AccentColor', { Default = Color3.fromRGB(97, 14, 166) });
Theme:AddToggle('Rainbow', { Text = 'Rainbow Accent Color' });
Theme:AddLabel('Outline Color'):AddColorPicker('OutlineColor', { Default = Library.OutlineColor });
Theme:AddLabel('Font Color'):AddColorPicker('FontColor', { Default = Library.FontColor });
Theme:AddButton('Default Theme', SetDefault);
Theme:AddToggle('Keybinds', { Text = 'Show Keybinds Menu', Default = true }):OnChanged(function()
    Library.KeybindFrame.Visible = Toggles.Keybinds.Value;
end);
Theme:AddToggle('Watermark', { Text = 'Show Watermark', Default = true }):OnChanged(function()
    Library:SetWatermarkVisibility(Toggles.Watermark.Value);
end);
local function tp()
    local Player = game.Players.LocalPlayer
    local TP = game:GetService("TeleportService")
    TP:Teleport(6055959032, Player)
end;
task.spawn(function()
    while game:GetService('RunService').RenderStepped:Wait() do
        if Toggles.Rainbow.Value then
            local Registry = Window.Holder.Visible and Library.Registry or Library.HudRegistry;

            for Idx, Object in next, Registry do
                for Property, ColorIdx in next, Object.Properties do
                    if ColorIdx == 'AccentColor' or ColorIdx == 'AccentColorDark' then
                        local Instance = Object.Instance;
                        local yPos = Instance.AbsolutePosition.Y;

                        local Mapped = Library:MapValue(yPos, 0, 1080, 0, 0.5) * 1.5;
                        local Color = Color3.fromHSV((Library.CurrentRainbowHue - Mapped) % 1, 0.8, 1);

                        if ColorIdx == 'AccentColorDark' then
                            Color = Library:GetDarkerColor(Color);
                        end;

                        Instance[Property] = Color;
                    end;
                end;
            end;
        end;
    end;
    
end);

task.spawn(function()
    while true do
        wait(1)

        if Library.Unloaded then break end
    end
end)

Toggles.Rainbow:OnChanged(function()
    if not Toggles.Rainbow.Value then
        UpdateTheme();
    end;
end);

Options.BackgroundColor:OnChanged(UpdateTheme);
Options.MainColor:OnChanged(UpdateTheme);
Options.AccentColor:OnChanged(UpdateTheme);
Options.OutlineColor:OnChanged(UpdateTheme);
Options.FontColor:OnChanged(UpdateTheme);

Library:OnUnload(function()
    print('Unloaded!')
    Library.Unloaded = true
end)
local function tp()
    local Player = game.Players.LocalPlayer
    local TP = game:GetService("TeleportService")
	game:GetService('TeleportService'):Teleport(game.PlaceId)
end;

local Extra = SettingsTab:AddRightTabbox("Extras")
local Feats = Extra:AddTab("Extras")
Feats:AddButton("Rejoin", tp)
Feats:AddLabel("discord || Devour#6859")

Theme:AddButton("Unload", function ()
    Library:Unload()
end)

Library:Notify("Loaded UI");



-- Features below

local lplr = game.Players.LocalPlayer -- Local Player
local camera = game:GetService("Workspace").CurrentCamera -- Camera
local CurrentCamera = game.Workspace.CurrentCamera -- Current Camera
local worldToViewportPoint = game.Workspace.CurrentCamera.worldToViewportPoint -- View Port Point
local UIS = game:GetService("UserInputService")

local dwCamera = game.Workspace.CurrentCamera
local dwRunService = game:GetService("RunService")
local dwUIS = game:GetService("UserInputService")
local dwEntities = game:GetService("Players")
local dwLocalPlayer = dwEntities.LocalPlayer
local dwMouse = dwLocalPlayer:GetMouse()

local HeadOff = Vector3.new(0, 0.2, 0)
local LegOff = Vector3.new(0,4.7,0)
local HeadOff2 = Vector3.new(0, 5.6, 0)
local SnapLeg = Vector3.new(0, 3.2, 0)
local HealthOff = Vector3.new(-6,0,0)
local currentGun = "M4A1"
local CurrentMap = "Gas Station"
local InGame = false
local DeathLoop = false

-- Box ESP
local BoxESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do
        local BoxOutline = Drawing.new("Square")
        BoxOutline.Visible = false
        BoxOutline.Color = Color3.new(0,0,0)
        BoxOutline.Thickness = 2
        BoxOutline.Transparency = 1
        BoxOutline.Filled = false
    
        local Box = Drawing.new("Square")
        Box.Visible = false
        Box.Color = Options.bColor.Value
        Box.Thickness = 1
        Box.Transparency = 1
        Box.Filled = false
    
        local HealthBarOutline = Drawing.new("Square")
        HealthBarOutline.Thickness = 3
        HealthBarOutline.Filled = false
        HealthBarOutline.Color = Color3.new(0,0,0)
        HealthBarOutline.Transparency = 1
        HealthBarOutline.Visible = false
    
        local HealthBar = Drawing.new("Square")
        HealthBar.Thickness = 1
        HealthBar.Filled = false
        HealthBar.Transparency = 1
        HealthBar.Visible = false
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    Box.Color = Options.bColor.Value
    
                    if onScreen and Toggles.boxes.Value == true or onScreen and Toggles.health_bar.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        BoxOutline.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        BoxOutline.Position = Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                        --BoxOutline.Visible = false
    
                        Box.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                        --Box.Visible = false
    
                        HealthBarOutline.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                        HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6,0)
                        --HealthBarOutline.Visible = false
                    
                        HealthBar.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) / (workspace[v.Character.Name].Humanoid.MaxHealth / math.clamp(workspace[v.Character.Name].Humanoid.Health, 0, workspace[v.Character.Name].Humanoid.MaxHealth)))
                        HealthBar.Position = Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                        HealthBar.Color = Color3.fromRGB(255 - 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 0)
                        --HealthBar.Visible = false

                        if texts <= Options.esp_distance.Value then

                            if Toggles.boxes.Value == true then
                                BoxOutline.Visible = true
                                Box.Visible = true
                            else
                                BoxOutline.Visible = false
                                Box.Visible = false
                            end
    
                            if Toggles.health_bar.Value == true then
                                HealthBar.Visible = true
                                HealthBarOutline.Visible = true
                            else
                                HealthBar.Visible = false
                                HealthBarOutline.Visible = false
                            end

                        else
                            BoxOutline.Visible = false
                            Box.Visible = false
                            HealthBar.Visible = false
                            HealthBarOutline.Visible = false
                        end
    
                    else
                        BoxOutline.Visible = false
                        Box.Visible = false
                        HealthBar.Visible = false
                        HealthBarOutline.Visible = false
                    end
                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                    HealthBar.Visible = false
                    HealthBarOutline.Visible = false
                end
            end)
    end
    
    game.Players.PlayerAdded:Connect(function(v)
        local BoxOutline = Drawing.new("Square")
        BoxOutline.Visible = false
        BoxOutline.Color = Color3.new(0,0,0)
        BoxOutline.Thickness = 2
        BoxOutline.Transparency = 1
        BoxOutline.Filled = false
    
        local Box = Drawing.new("Square")
        Box.Visible = false
        Box.Color = Options.bColor.Value
        Box.Thickness = 1
        Box.Transparency = 1
        Box.Filled = false
    
        local HealthBarOutline = Drawing.new("Square")
        HealthBarOutline.Thickness = 3
        HealthBarOutline.Filled = false
        HealthBarOutline.Color = Color3.new(0,0,0)
        HealthBarOutline.Transparency = 1
        HealthBarOutline.Visible = false
    
        local HealthBar = Drawing.new("Square")
        HealthBar.Thickness = 1
        HealthBar.Filled = false
        HealthBar.Transparency = 1
        HealthBar.Visible = false
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    Box.Color = Options.bColor.Value
    
                    if onScreen and Toggles.boxes.Value == true or onScreen and Toggles.health_bar.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        BoxOutline.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        BoxOutline.Position = Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                        --BoxOutline.Visible = false
    
                        Box.Size = Vector2.new(1650 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                        --Box.Visible = false
    
                        HealthBarOutline.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                        HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6,0)
                        --HealthBarOutline.Visible = false
                    
                        HealthBar.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) / (workspace[v.Character.Name].Humanoid.MaxHealth / math.clamp(workspace[v.Character.Name].Humanoid.Health, 0, workspace[v.Character.Name].Humanoid.MaxHealth)))
                        HealthBar.Position = Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                        HealthBar.Color = Color3.fromRGB(255 - 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 255 / (workspace[v.Character.Name].Humanoid.MaxHealth / workspace[v.Character.Name].Humanoid.Health), 0)
                        --HealthBar.Visible = false
    
                        if texts <= Options.esp_distance.Value then

                            if Toggles.boxes.Value == true then
                                BoxOutline.Visible = true
                                Box.Visible = true
                            else
                                BoxOutline.Visible = false
                                Box.Visible = false
                            end
    
                            if Toggles.health_bar.Value == true then
                                HealthBar.Visible = true
                                HealthBarOutline.Visible = true
                            else
                                HealthBar.Visible = false
                                HealthBarOutline.Visible = false
                            end

                        else
                            BoxOutline.Visible = false
                            Box.Visible = false
                            HealthBar.Visible = false
                            HealthBarOutline.Visible = false
                        end
    
                    else
                        BoxOutline.Visible = false
                        Box.Visible = false
                        HealthBar.Visible = false
                        HealthBarOutline.Visible = false
                    end
                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                    HealthBar.Visible = false
                    HealthBarOutline.Visible = false
                end
            end)
    end)

end
coroutine.wrap(BoxESP)()

-- Head Dot ESP
local HeadDotESP = function ()
    
    for i,v in pairs(game.Players:GetChildren()) do

        local CircleOutline = Drawing.new("Circle")
        CircleOutline.Visible = false
        CircleOutline.Radius = 30
        CircleOutline.Color = Color3.fromRGB(0, 0 ,0)
        CircleOutline.Thickness = 3
        CircleOutline.Filled = false
        CircleOutline.Transparency = 1
    
        local HeadCircle = Drawing.new("Circle")
        HeadCircle.Visible = false
        HeadCircle.Radius = 30
        HeadCircle.Color = Options.bColor.Value
        HeadCircle.Thickness = 1
        HeadCircle.Filled = false
        HeadCircle.Transparency = 1
    
            game:GetService("RunService").RenderStepped:Connect(function()
    
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
    
                    HeadCircle.Color = Options.bColor.Value
    
                    if onScreen == true and Toggles.head_dot.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        HeadCircle.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        HeadCircle.Radius = 350 / RootPosition.Z
                        HeadCircle.Visible = true
    
                        CircleOutline.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        CircleOutline.Radius = 350 / RootPosition.Z
                        CircleOutline.Visible = true

if texts <= Options.esp_distance.Value then
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        else
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        end

                    else
                        HeadCircle.Visible = false
                        CircleOutline.Visible = false
                    end
    
                else
                    HeadCircle.Visible = false
                    CircleOutline.Visible = false
                end
    
            end)
            
    end
    
    game.Players.PlayerAdded:Connect(function(v)
        
        local CircleOutline = Drawing.new("Circle")
        CircleOutline.Visible = false
        CircleOutline.Radius = 30
        CircleOutline.Color = Color3.fromRGB(0, 0 ,0)
        CircleOutline.Thickness = 3
        CircleOutline.Filled = false
        CircleOutline.Transparency = 1
    
        local HeadCircle = Drawing.new("Circle")
        HeadCircle.Visible = false
        HeadCircle.Radius = 30
        HeadCircle.Color = Options.bColor.Value
        HeadCircle.Thickness = 1
        HeadCircle.Filled = false
        HeadCircle.Transparency = 1
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                    
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
    
                    HeadCircle.Color = Options.bColor.Value
    
                    if onScreen == true and Toggles.head_dot.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                        HeadCircle.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        HeadCircle.Radius = 350 / RootPosition.Z
                        HeadCircle.Visible = true
    
                        CircleOutline.Position = Vector2.new(HeadPosition.X / 1, HeadPosition.Y / 1)
                        CircleOutline.Radius = 350 / RootPosition.Z
                        CircleOutline.Visible = true
    
if texts <= Options.esp_distance.Value then
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        else
                            HeadCircle.Visible = true
                            CircleOutline.Visible = true
                        end

                    else
                        HeadCircle.Visible = false
                        CircleOutline.Visible = false
                    end
    
                else
                    HeadCircle.Visible = false
                    CircleOutline.Visible = false
                end
    
            end)
    end)

end
coroutine.wrap(HeadDotESP)()

-- Nametag ESP
local NametagESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do

        local NameESP = Drawing.new("Text")
        NameESP.Visible = false
        NameESP.Center = true
        NameESP.Outline = true
        NameESP.Font = Options.SelectedFont.Value
        NameESP.Size = Options.FontSize.Value
        NameESP.Color = Options.nameColor.Value
        NameESP.Text = v.Name
    
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, RootPart.Position + HeadOff2)
    
                    NameESP.Color = Options.nameColor.Value
                    NameESP.Size = Options.FontSize.Value
                    NameESP.Font = Options.SelectedFont.Value

                    if onScreen == true and Toggles.name_tags.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        NameESP.Position = Vector2.new(HeadPosition.X, HeadPosition.Y)
if texts <= Options.esp_distance.Value then
                            NameESP.Visible = true
                        else
                            NameESP.Visible = true
                        end

                    else
                        NameESP.Visible = false
                    end
    
                else
                    NameESP.Visible = false
                end
    
            end)
            
    end
    
    
    game.Players.PlayerAdded:Connect(function (v)
    
        local NameESP = Drawing.new("Text")
        NameESP.Visible = false
        NameESP.Center = true
        NameESP.Outline = true
        NameESP.Font = Options.SelectedFont.Value
        NameESP.Size = Options.FontSize.Value
        NameESP.Color = Options.nameColor.Value
        NameESP.Text = v.Name
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local HeadPosition = worldToViewportPoint(CurrentCamera, RootPart.Position + HeadOff2)
    
                    NameESP.Color = Options.nameColor.Value
                    NameESP.Size = Options.FontSize.Value
                    NameESP.Font = Options.SelectedFont.Value
    
                    if onScreen == true and Toggles.name_tags.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        NameESP.Position = Vector2.new(HeadPosition.X, HeadPosition.Y)
    
    
 if texts <= Options.esp_distance.Value then
                            NameESP.Visible = true
                        else
                            NameESP.Visible = true
                        end

                    else
                        NameESP.Visible = false
                    end
    
                else
                    NameESP.Visible = false
                end
    
            end)
            
    
    end)
end
coroutine.wrap(NametagESP)()

-- Distance ESP
local DistanceESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do

        local DistESP = Drawing.new("Text")
        DistESP.Visible = false
        DistESP.Center = true
        DistESP.Outline = true
        DistESP.Font = Options.SelectedFont.Value
        DistESP.Size = Options.FontSize.Value
        DistESP.Color = Options.nameColor.Value
        DistESP.Text = ""
    
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    DistESP.Font = Options.SelectedFont.Value
                    DistESP.Size = Options.FontSize.Value
                    DistESP.Color = Options.nameColor.Value

                    --  or texts < 300 

                    if onScreen == true and Toggles.distance.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        DistESP.Position = Vector2.new(LegPosition.X, LegPosition.Y)
                        
                        DistESP.Text = tostring("(" .. texts .. ")")

                        if texts <= Options.esp_distance.Value then
                            DistESP.Visible = true
                        else
                            DistESP.Visible = false
                        end

                    else
                        DistESP.Visible = false
                    end
    
                else
                    DistESP.Visible = false
                end
    
            end)
    end
    
    game.Players.PlayerAdded:Connect(function (v)
    
        local DistESP = Drawing.new("Text")
        DistESP.Visible = false
        DistESP.Center = true
        DistESP.Outline = true
        DistESP.Font = Options.SelectedFont.Value
        DistESP.Size = Options.FontSize.Value
        DistESP.Color = Options.nameColor.Value
        DistESP.Text = ""
    
            game:GetService("RunService").RenderStepped:Connect(function()
                if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
    
                    local TextVect, onScreen = camera:WorldToViewportPoint(v.Character.Head.Position)
                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)  
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)
    
                    DistESP.Font = Options.SelectedFont.Value
                    DistESP.Size = Options.FontSize.Value
                    DistESP.Color = Options.nameColor.Value
                    
                    if onScreen == true and Toggles.distance.Value == true then
    
                        local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)
    
                        DistESP.Position = Vector2.new(LegPosition.X, LegPosition.Y)
                        
                        DistESP.Text = tostring("(" .. texts .. ")")
    
if texts <= Options.esp_distance.Value then
                            DistESP.Visible = true
                        else
                            DistESP.Visible = true
                        end

                    else
                        DistESP.Visible = false
                    end
    
                else
                    DistESP.Visible = false
                end
    
            end)
    
    end)

end
coroutine.wrap(DistanceESP)()

-- Snaplines ESP
local SnaplineESP = function ()

    for i,v in pairs(game.Players:GetChildren()) do

        local lineSnap = Drawing.new("Line")
        lineSnap.Visible =  false
        lineSnap.Thickness = 1
        lineSnap.Color = Options.bColor.Value
        
        game:GetService("RunService").RenderStepped:Connect(function ()
            if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)   
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - SnapLeg)
    
                lineSnap.Color = Options.bColor.Value
    
                if onScreen and Toggles.snaplines.Value == true then
    
                    local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                    if Options.SnaplinePart.Value == "Head" then
                        lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                        lineSnap.To = Vector2.new(HeadPosition.X, HeadPosition.Y)
                    else 
                        if Options.SnaplinePart.Value == "Torso" then
                            lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                            lineSnap.To = Vector2.new(RootPosition.X, RootPosition.Y)
                        else
                            if Options.SnaplinePart.Value == "Legs" then
                                lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                                lineSnap.To = Vector2.new(LegPosition.X, LegPosition.Y)
                            end
                        end
end
if texts <= Options.esp_distance.Value then
                        lineSnap.Visible = true
                    else
                        lineSnap.Visible = true
                    end

                else
                    lineSnap.Visible = false
                end
            else
                lineSnap.Visible = false
            end
        end)
    end
    game.Players.PlayerAdded:Connect(function (v)
    
        local lineSnap = Drawing.new("Line")
        lineSnap.Visible =  false
        lineSnap.Thickness = 1
        lineSnap.Color = Options.bColor.Value
        
        game:GetService("RunService").RenderStepped:Connect(function ()
            if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
    
                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)   
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - SnapLeg)
    
                lineSnap.Color = Options.bColor.Value
    
                if onScreen and Toggles.snaplines.Value == true then
    
                    local texts = math.ceil((RootPart.Position - game:GetService("Workspace").Camera.CFrame.Position).magnitude)

                    if Options.SnaplinePart.Value == "Head" then
                        lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                        lineSnap.To = Vector2.new(HeadPosition.X, HeadPosition.Y)
                    else 
                        if Options.SnaplinePart.Value == "Torso" then
                            lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                            lineSnap.To = Vector2.new(RootPosition.X, RootPosition.Y)
                        else
                            if Options.SnaplinePart.Value == "Legs" then
                                lineSnap.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                                lineSnap.To = Vector2.new(LegPosition.X, LegPosition.Y)
                            end
                        end
                       end 
if texts <= Options.esp_distance.Value then
                        lineSnap.Visible = true
                    else
                        lineSnap.Visible = true
                    end

                else
                    lineSnap.Visible = false
                end
            else
                lineSnap.Visible = false
            end
        end)
    
    end)

end
coroutine.wrap(SnaplineESP)()
function localChams()
    game:GetService("RunService").RenderStepped:Connect(function()
        if Toggles.hand_chams.Value == true then
            for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
                if v:IsA("BasePart") then
                    
                    v.BrickColor = BrickColor.new(Options.handColor.Value)
                    v.Material = Options.hand_mat.Value
                    v.Transparency = Options.hand_chams_transparency.Value / 100

                end
                
            end
        end
    end)
end
coroutine.wrap(localChams)()
function FeAll()
while wait(1) do
if Toggles.Fe_All.Value == true then
function GetPlayer(String)
   local Found = {}
   local strl = String:lower()
   if strl == "all" then
       for i,v in pairs(game.Players:GetPlayers()) do
           table.insert(Found,v.Name)
       end
   elseif strl == "others" then
       for i,v in pairs(game.Players:GetPlayers()) do
           if v.Name ~= game.Players.LocalPlayer.Name then
               table.insert(Found,v.Name)
           end
       end   
elseif strl == "me" then
       for i,v in pairs(game.Players:GetPlayers()) do
           if v.Name == game.Players.LocalPlayer.Name then
               table.insert(Found,v.Name)
           end
       end  
   else
       for i,v in pairs(game.Players:GetPlayers()) do
           if v.Name:lower():sub(1, #String) == String:lower() then
               table.insert(Found,v.Name)
           end
       end    
   end
   return Found    
end
local LP = game.Players.LocalPlayer
local Char,Pack = LP.Character,LP.Backpack
local HRP,Hum = Char.HumanoidRootPart,Char.Humanoid
local LS = LP.PlayerGui:FindFirstChild("LocalScript")
local plrs = game:GetService("Players")
local OHRP = plrs:GetChildren()
local FETO = plrs:FindFirstChildWhichIsA("Part")
if LS then LS:Destroy() end

for i = 1, #OHRP do
print(i, OHRP[i].Name)
end

LP.CharacterAdded:Connect(function(fe)
fe:WaitForChild("Right Leg"):Destroy()
fe:WaitForChild("Humanoid")
fe:WaitForChild("HumanoidRootPart") wait(0.01)
local CL = fe:WaitForChild("Humanoid"):Clone()
fe:WaitForChild("Humanoid"):Destroy()
CL.Parent = fe
fe.Humanoid:ChangeState(15)
end)

game:GetService("RunService").RenderStepped:Connect(function()
for p, GetPlayer in pairs(plrs:GetChildren())do
if GetPlayer.Name ~= plrs.LocalPlayer.Name then
    if GetPlayer.Character:FindFirstChild("Humanoid") then
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = GetPlayer.Character.Torso.CFrame
wait()
end
end
end
end)
while wait() do
    for i,v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
            v.Parent = game.Players.LocalPlayer.Character
        end
end
end
end
end
coroutine.wrap(FeAll)()
function FeGod()
while wait(5) do
if Toggles.Fe_Godmode.Value == true then
local lp = game:GetService "Players".LocalPlayer
if lp.Character:FindFirstChild "Head" then
    local char = lp.Character
    char.Archivable = true
    local new = char:Clone()
    new.Parent = workspace
    lp.Character = new
    wait(2)
    local oldhum = char:FindFirstChildWhichIsA "Humanoid"
    local newhum = oldhum:Clone()
    newhum.Parent = char
    newhum.RequiresNeck = false
    oldhum.Parent = nil
    wait(2)
    lp.Character = char
    new:Destroy()
    wait(1)
    newhum:GetPropertyChangedSignal("Health"):Connect(
        function()
            if newhum.Health <= 0 then
                oldhum.Parent = lp.Character
                wait(1)
                oldhum:Destroy()
            end
        end)
    workspace.CurrentCamera.CameraSubject = char
    if char:FindFirstChild "Animate" then
        char.Animate.Disabled = true
        wait(.1)
        char.Animate.Disabled = false
end
rs:Disconnect()
end
    end
end
end
coroutine.wrap(FeAll)()
-- Enemy Chams
function chams()
    game:GetService("RunService").RenderStepped:Connect(function()
        if Toggles.enemy_chams.Value == true then
            for i,v in pairs(game.Players:GetChildren()) do
                for i,b in pairs(v.Character:GetChildren()) do
                    if b:IsA("BasePart") and v.Character.Humanoid.Health > 0 then
                        if not b:FindFirstChild("BoxHandleAdornment") then
                            b.Transparency = 0.5
                            local box = Instance.new("BoxHandleAdornment", b)
                            box.AlwaysOnTop = Toggles.enemy_chams_ontop.Value
                            box.Adornee = b
                            box.Size = b.Size
                            box.Color3 = Options.eColor.Value
                            box.ZIndex = 1                                         
                            box.Transparency = Options.enemy_chams_transparency.Value / 100
if game.Players.LocalPlayer.Character:FindFirstChild("BoxHandleAdornment") then
box:Destroy()
                            repeat wait()
                                box.Color3 = Options.eColor.Value
                                box.Transparency = Options.enemy_chams_transparency.Value / 100
                                box.AlwaysOnTop = Toggles.enemy_chams_ontop.Value
                            until Toggles.enemy_chams.Value == false
                        end
                    end
                end
            end
        end
end
    end)
end
coroutine.wrap(chams)()

function destroyChams()
    game:GetService("RunService").RenderStepped:Connect(function ()
        if Toggles.enemy_chams.Value == false then
           for i,v in pairs(game.Players:GetChildren()) do
              for i,b in pairs(v.Character:GetChildren()) do
                  if b:IsA("BasePart") then
                      if b:FindFirstChild("BoxHandleAdornment") then
                          b.BoxHandleAdornment:Destroy()
                      end
                  end
              end
           end
end
    end)
end
coroutine.wrap(destroyChams)()

-- Crosshair
local CrosshairDown = Drawing.new("Line") -- y
local CrosshairCross = Drawing.new("Line") -- x
local UserInputService = game:GetService("UserInputService")

function makeCrosshair()
    game:GetService("RunService").RenderStepped:Connect(function ()
        if Toggles.crosshair.Value == true then

            CrosshairDown.Color = Options.crossColor.Value
            CrosshairDown.Thickness = Options.cross_thickness.Value
            CrosshairDown.Transparency = Options.cross_trans.Value / 100

            CrosshairCross.Color = Options.crossColor.Value
            CrosshairCross.Thickness = Options.cross_thickness.Value
            CrosshairCross.Transparency = Options.cross_trans.Value / 100

            if Toggles.crosshair.Value == true then

                CrosshairDown.Visible = true
                CrosshairCross.Visible = true
            
                CrosshairCross.From = Vector2.new(UserInputService:GetMouseLocation().X+(Options.cross_length.Value/2), UserInputService:GetMouseLocation().Y) 
                CrosshairCross.To = Vector2.new(UserInputService:GetMouseLocation().X-(Options.cross_length.Value/2), UserInputService:GetMouseLocation().Y)

                CrosshairDown.From = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y+(Options.cross_length.Value/2)) 
                CrosshairDown.To = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y-(Options.cross_length.Value/2))

            else
                CrosshairDown.Visible = false
                CrosshairCross.Visible = false
            end

        else
            CrosshairDown.Visible = false
            CrosshairCross.Visible = false
        end

    end)
end
coroutine.wrap(makeCrosshair)()

local aiming = false
local selectKey = Options.aim_key.Value
local fovcircle = Drawing.new("Circle")
local peekPressed = false
local origPos = CFrame.new(0,0,0)
local changedPos = CFrame.new(0,0,0)
local deathLoopPos = CFrame.new(0,0,0)

fovcircle.Visible = Toggles.fov_Circle.Value
fovcircle.Radius = Options.circle_radius.Value
fovcircle.Color = Options.fovColor.Value
fovcircle.Thickness = 1
fovcircle.Filled = false
fovcircle.Transparency = 1

fovcircle.Position = Vector2.new(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y / 2)

UIS.InputBegan:Connect(function(i)
    if i.KeyCode == Enum.KeyCode[Options.aim_key.Value] then
        aiming = true
        print("Aiming")
        print(Options.aim_key.Value)
    end
end)

UIS.InputEnded:Connect(function(i)
    if i.KeyCode == Enum.KeyCode[Options.aim_key.Value] then
        aiming = false
        print("Not Aiming")
        print(Options.aim_key.Value)
    end
end)

dwRunService.RenderStepped:Connect(function()
    
    local dist = math.huge -- controls the fov snap stuff
    local closest_char = nil

    fovcircle.Radius = Options.circle_radius.Value
    fovcircle.Color = Options.fovColor.Value
    fovcircle.Visible = Toggles.fov_Circle.Value

    
    if aiming and Toggles.aim_enabled.Value == true then

        for i,v in next, dwEntities:GetChildren() do 

            if v ~= dwLocalPlayer and
            v.Character and
            v.Character:FindFirstChild("HumanoidRootPart") and
            v.Character:FindFirstChild("Humanoid") and
            v.Character:FindFirstChild("Humanoid").Health > 0 then

                if v.Team ~= dwLocalPlayer.Team then

                    local char = v.Character
                    local char_part_pos, is_onscreen = dwCamera:WorldToViewportPoint(char[Options.aim_part.Value].Position)

                    if is_onscreen then

                        local mag = (Vector2.new(dwMouse.X, dwMouse.Y) - Vector2.new(char_part_pos.X, char_part_pos.Y)).Magnitude

                        if mag < dist and mag < Options.circle_radius.Value then

                            dist = mag
                            closest_char = char

                        end
                    end
                end
            end
        end

        if closest_char ~= nil and
        closest_char:FindFirstChild("HumanoidRootPart") and
        closest_char:FindFirstChild("Humanoid") and
        closest_char:FindFirstChild("Humanoid").Health > 0 and TweenStatus == nil then

            dwCamera.CFrame = CFrame.new(dwCamera.CFrame.Position, closest_char[Options.aim_part.Value].Position)
            --mousemoverel(((closest_char[Options.aim_part.Value].Position.X - MouseLocation.X)  / 0.5), ((closest_char[Options.aim_part.Value].Position.Y - MouseLocation.Y) / 0.5))
        end

    end
end)

local playerMods = function ()
    
    game:GetService("RunService").RenderStepped:Connect(function()

        if Toggles.plr_mod.Value == true then

            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Options.player_speed.Value
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = Options.player_height.Value

        else

        end
    end)

end
coroutine.wrap(playerMods)()

local PhaseKey = function ()
end
coroutine.wrap(PhaseKey)()


local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
local HumanoidRootPart = Player.Character:WaitForChild("HumanoidRootPart")
local Humanoid = Player.Character:WaitForChild("Humanoid")
local Flying = false
local Control = {f = 0, b = 0, l = 0, r = 0} 
local LastControl = {f = 0, b = 0, l = 0, r = 0} 
local MaxSpeed = 50 
local Speed = 10    
local Camera = workspace.CurrentCamera
                local WKey = Enum.KeyCode.W
                local AKey = Enum.KeyCode.A
                local SKey = Enum.KeyCode.S
                local DKey = Enum.KeyCode.D

if Player:FindFirstChildOfClass("PlayerGui"):FindFirstChild("DConsole_FLY_SCRIPT") then
    wait(1)
    Player:FindFirstChildOfClass("PlayerGui"):FindFirstChild("DConsole_FLY_SCRIPT"):remove()
    if Player.Character.HumanoidRootPart:FindFirstChild("BodyGyro") then
    Player.Character.HumanoidRootPart:FindFirstChild("BodyGyro"):Destroy()
    end
if Player.Character.HumanoidRootPart:FindFirstChild("BodyVelocity") then
    Player.Character.HumanoidRootPart:FindFirstChild("BodyVelocity"):Destroy()
end
end

if Player.Character:FindFirstChild("Humanoid").Health == 0 then
    wait(1)
    script:Destroy()
    return
end

Instance.new("StringValue",script).Name = "DO_NOT_REENABLE"			

script.Parent = Player:FindFirstChild("PlayerGui")
script.Name = "DConsole_FLY_SCRIPT"

function Fly() 
    local Gyro = Instance.new("BodyGyro", HumanoidRootPart) 
    Gyro.P = 9e4 
    Gyro.maxTorque = Vector3.new(9e9, 9e9, 9e9) 
    Gyro.cframe = HumanoidRootPart.CFrame 
    
    local Velocity = Instance.new("BodyVelocity", HumanoidRootPart) 
    Velocity.velocity = Vector3.new(0,0.1,0) 
    Velocity.maxForce = Vector3.new(9e9, 9e9, 9e9) 
    
    repeat
        wait() 
        
        Humanoid.PlatformStand = true 
        
        if Control.l + Control.r + Control.f + Control.b > 0 then

        else

        end
        
        if Control.l + Control.r ~= 0 or Control.f + Control.b ~= 0 then 
        
            Speed = Speed+.5+(Speed/MaxSpeed) 
            
            if Speed > MaxSpeed then 
                Speed = MaxSpeed 
            end 
        elseif not (Control.l + Control.r ~= 0 or Control.f + Control.b ~= 0) and Speed ~= 0 then 
            Speed = Speed-1 
            if Speed < 0 then 
                Speed = 0
            end 
        end 
            
        if (Control.l + Control.r) ~= 0 or (Control.f + Control.b) ~= 0 then 
        
            Velocity.velocity = 
                ((Camera.CoordinateFrame.lookVector * (Control.f + Control.b)) +
                ((Camera.CoordinateFrame * CFrame.new(Control.l + Control.r,(Control.f + Control.b) * 0.2, 0).p) - --yuck
                Camera.CoordinateFrame.p))*Speed
                
            LastControl = {f = Control.f, b = Control.b, l = Control.l, r = Control.r}
            
        elseif (Control.l + Control.r) == 0 and (Control.f + Control.b) == 0 and Speed ~= 0 then 
        
            Velocity.velocity = 
                ((Camera.CoordinateFrame.lookVector * (LastControl.f + LastControl.b)) +
                ((Camera.CoordinateFrame * CFrame.new(LastControl.l + LastControl.r, (LastControl.f + LastControl.b) * 0.2, 0).p) - --also yuck
                Camera.CoordinateFrame.p))*Speed 
                
        else 
            Velocity.velocity = Vector3.new(0,0.1,0) 
        end
        
        Gyro.cframe = Camera.CoordinateFrame * CFrame.Angles(-math.rad((Control.f+Control.b)*50*Speed/MaxSpeed),0,0) 
        
    until not Flying or not script.Parent
    
    Control = {f = 0, b = 0, l = 0, r = 0} 
    LastControl = {f = 0, b = 0, l = 0, r = 0} 
    Speed = 0
    Gyro:Destroy()
    Velocity:Destroy()
    Humanoid.PlatformStand = false 
    
end
                UIS.InputBegan:Connect(function(i)
                    if i.KeyCode == Enum.KeyCode[Options.flyKey.Value] then
        Flying = not Flying
        if Flying then
            Fly()
        end
                    elseif i.KeyCode == WKey then
                        Control.f = 1 
                    elseif i.KeyCode == SKey then
                        Control.b = -1 
                    elseif i.KeyCode == AKey then
                        Control.l = -1 
                    elseif i.KeyCode == DKey then
                        Control.r = 1 
                    end
                end)
                
                UIS.InputEnded:Connect(function(i)
                    if i.KeyCode == WKey then
                        Control.f = 0 
                    elseif i.KeyCode == SKey then
                        Control.b = 0
                    elseif i.KeyCode == AKey then
                        Control.l = 0 
                    elseif i.KeyCode == DKey then
                        Control.r = 0 
                    end
                end)
                Fly()
if Flying then
Library:Notify("Flying")
end
if not Flying then
Library:Notify("Not Flying")
end
local RenderEdit = function ()

    local filter = Instance.new("ColorCorrectionEffect", game:GetService("Workspace").Camera)
    local bloom = Instance.new("BloomEffect", game:GetService("Workspace").Camera)

    game:GetService("RunService").RenderStepped:Connect(function ()
        
        if Toggles.clr_correction.Value == true then
            filter.Brightness = Options.brightness.Value / 100
            filter.Contrast = Options.contrast.Value / 100
            filter.Enabled = true
            filter.Saturation = Options.saturation.Value / 100
            filter.TintColor = Options.clrCorrct.Value
        if Toggles.bloom.Value == true then
            
            bloom.Enabled = true
            bloom.Intensity = Options.bloom_intensity.Value / 100
            bloom.Size = Options.bloom_size.Value
            bloom.Threshold = Options.bloom_threshold.Value
        else
            bloom.Enabled = false
        end
        end
    end)
end
coroutine.wrap(RenderEdit)()
local KeysTable = {
    ["W"] = false;["A"] = false;
    ["S"] = false;["D"] = false;
    ["LeftControl"] = false;["LeftShift"] = false;
}
local Uis = game:GetService("UserInputService")
local rm = getrawmetatable(game) or debug.getrawmetatable(game) or getmetatable(game)
local Flyspeed, Blinkspeed = 5, 2;

local Players, RService, RStorage, VUser, SGui, TPService = game:GetService("Players"), game:GetService("RunService"), game:GetService("ReplicatedStorage"), game:GetService("VirtualUser"), game:GetService("StarterGui"), game:GetService("TeleportService")
local Client, Mouse, Camera, CF, INew, Vec3, Vec2, UD2, UD = Players.LocalPlayer, Players.LocalPlayer:GetMouse(), workspace.CurrentCamera, CFrame.new, Instance.new, Vector3.new, Vector2.new, UDim2.new, UDim.new;
if setreadonly then setreadonly(rm, true) else make_writeable(rm, false) end
local Flying, NoClip = false,false

RService.Stepped:Connect(function()
    if NoClip == true and LocalP and LocalP.Character and LocalP.Character:FindFirstChild("Humanoid") then  -- fuck errors
            for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                    
                end
            end
        end
    end)
                UIS.InputBegan:Connect(function(i)
                    if i.KeyCode == Enum.KeyCode[Options.phaseKey.Value] then
        NoClip = not NoClip
Library:Notify("Noclip active")
    end
end)
Library:Notify("Loading Done")
local Plr = game:GetService("Players").LocalPlayer
local Mouse = Plr:GetMouse()

Mouse.Button1Down:connect(function()
if not game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode[Options.tpKey.Value]) then return end --You can change the "LeftControl" to another hotkey
if not Mouse.Target then return end
Plr.Character:MoveTo(Mouse.Hit.p)
end)

    local bgui = Instance.new("BillboardGui", game.Players.LocalPlayer.Character.Head)
    local tlabel = Instance.new("TextLabel", bgui)
    
    bgui.Name = "ESP"
    bgui.Adornee = part
    bgui.AlwaysOnTop = true
    bgui.ExtentsOffset = Vector3.new(0, 3, 0)
    bgui.Size = UDim2.new(0, 5, 0, 5)
        
    tlabel.Name = "espTarget"
    tlabel.BackgroundColor3 = Color3.fromRGB(0,255,255)
    tlabel.BackgroundTransparency = 1
    tlabel.BorderSizePixel = 0
    tlabel.Position = UDim2.new(0, 0, 0, -30)
    tlabel.Size = UDim2.new(1, 0, 7, 0)
    tlabel.Visible = true
    tlabel.ZIndex = 10
    tlabel.Font = "Code"
    tlabel.FontSize = "Size14"
    tlabel.TextSize = 23.000
        if game.Players and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then 
            text = "dev-hook"
while wait() do
for i = 1, #text do
	tlabel.Text = string.sub(text,1,i)
		wait(0.4)
	end
end	

        end
